name: Validate Balatro Mods

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
      - edited

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: refs/pull/${{ github.event.pull_request.number }}/head
          persist-credentials: false

      - name: Use ImageMagick from cache
        uses: awalsh128/cache-apt-pkgs-action@v1
        with:
          packages: imagemagick
          version: 8:6.9.12.98+dfsg1-5.2build2

      - name: Initialize validation report
        run: |
          REPORT_FILE="$RUNNER_TEMP/validation_report.txt"
          WARNING_FILE="$RUNNER_TEMP/validation_warnings.txt"
          : > "$REPORT_FILE"
          : > "$WARNING_FILE"
          echo "REPORT_FILE=$REPORT_FILE" >> "$GITHUB_ENV"
          echo "WARNING_FILE=$WARNING_FILE" >> "$GITHUB_ENV"

      - name: Identify Changed Mods
        id: find-changed-mods
        run: |
          : > changed_mods.txt
          : > changed_files.txt

          api_ok=true
          page=1
          while true; do
            API_RESPONSE=$(curl --silent --show-error --location \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files?per_page=100&page=${page}") || api_ok=false

            if [ "$api_ok" != "true" ] || ! echo "$API_RESPONSE" | jq -e 'type=="array"' >/dev/null; then
              api_ok=false
              break
            fi

            count=$(echo "$API_RESPONSE" | jq 'length')
            if [ "$count" -eq 0 ]; then
              break
            fi

            echo "$API_RESPONSE" | jq -r '.[] | .filename' >> changed_files.txt

            if [ "$count" -lt 100 ]; then
              break
            fi
            page=$((page + 1))
          done

          if [ "$api_ok" = "true" ] && [ -s changed_files.txt ]; then
            echo "Using GitHub API method to find changed files"
            grep -E '^mods/[^/]+/' changed_files.txt | cut -d'/' -f1-2 | sort -u > changed_mods.txt || true
          else
            echo "Using git diff method as fallback"
            git fetch origin "${{ github.event.pull_request.base.ref }}"
            git diff --name-only --diff-filter=AM "origin/${{ github.event.pull_request.base.ref }}...HEAD" | grep -E '^mods/[^/]+/' | cut -d'/' -f1-2 | sort -u > changed_mods.txt || true
          fi

          if [ ! -s changed_mods.txt ]; then
            echo "No mods were added or modified in this PR."
            echo "changed_mods_found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Changed mods found:"
          cat changed_mods.txt
          echo "changed_mods_found=true" >> "$GITHUB_OUTPUT"

          META_JSON_FILES=$(
            while read -r mod_path; do
              if [ -f "$mod_path/meta.json" ]; then
                echo "$mod_path/meta.json"
              fi
            done < changed_mods.txt
          )

          echo "meta_json_files<<EOF" >> "$GITHUB_OUTPUT"
          echo "$META_JSON_FILES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Check Required Files
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true'
        run: |
          while read -r mod_path; do
            if [ -d "$mod_path" ]; then
              MOD_DIR="$(basename "$mod_path")"

              if [ ! -f "$mod_path/description.md" ]; then
                echo "- '$MOD_DIR': Missing description.md" >> "$REPORT_FILE"
              fi

              if [ ! -f "$mod_path/meta.json" ]; then
                echo "- '$MOD_DIR': Missing meta.json" >> "$REPORT_FILE"
              fi
            fi
          done < changed_mods.txt

      - name: Check Thumbnail Dimensions
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true'
        run: |
          while read -r mod_path; do
            if [ -d "$mod_path" ]; then
              MOD_DIR="$(basename "$mod_path")"
              THUMBNAIL="$mod_path/thumbnail.jpg"

              INVALID_THUMBNAILS=$(find "$mod_path" -maxdepth 1 -type f -print \
                | awk -F/ '{print $NF}' \
                | grep -Ei '^thumbnail\.' \
                | grep -Ev '^thumbnail\.jpg$' || true)

              if [ -n "$INVALID_THUMBNAILS" ]; then
                INVALID_LIST=$(echo "$INVALID_THUMBNAILS" | tr '\n' ',' | sed 's/,$//')
                echo "- '$MOD_DIR': Invalid thumbnail filename(s): $INVALID_LIST (only thumbnail.jpg is allowed)" >> "$REPORT_FILE"
              fi

              if [ -f "$THUMBNAIL" ]; then
                MIME_TYPE=$(file --brief --mime-type "$THUMBNAIL")
                if [ "$MIME_TYPE" != "image/jpeg" ]; then
                  echo "- '$MOD_DIR': thumbnail.jpg must be a JPEG (found: $MIME_TYPE)" >> "$REPORT_FILE"
                fi

                DIMENSIONS=$(/usr/bin/identify-im6.q16 -format "%wx%h" "$THUMBNAIL")
                WIDTH=$(echo "$DIMENSIONS" | cut -dx -f1)
                HEIGHT=$(echo "$DIMENSIONS" | cut -dx -f2)

                if [ "$WIDTH" -gt 1920 ] || [ "$HEIGHT" -gt 1080 ]; then
                  echo "- '$MOD_DIR': thumbnail.jpg exceeds 1920x1080 recommendation" >> "$WARNING_FILE"
                fi
              fi
            fi
          done < changed_mods.txt

      - name: Validate JSON Format
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true'
        run: |
          while read -r mod_path; do
            if [ -f "$mod_path/meta.json" ]; then
              if ! jq empty "$mod_path/meta.json" 2>/dev/null; then
                echo "- '$mod_path': meta.json is not valid JSON" >> "$REPORT_FILE"
              fi
            fi
          done < changed_mods.txt

      - name: Validate meta.json Against Schema
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true' && steps.find-changed-mods.outputs.meta_json_files != ''
        id: schema-validation
        continue-on-error: true
        uses: dsanders11/json-schema-validate-action@v1.4.0
        with:
          schema: "./schema/meta.schema.json"
          files: ${{ steps.find-changed-mods.outputs.meta_json_files }}
          all-errors: true
          custom-errors: true

      - name: Record Schema Validation Errors
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true' && steps.schema-validation.outcome == 'failure'
        run: |
          echo "- One or more meta.json files do not match schema/meta.schema.json" >> "$REPORT_FILE"

      - name: Validate Metadata Logic
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true'
        run: |
          while read -r mod_path; do
            if [ -d "$mod_path" ]; then
              MOD_DIR="$(basename "$mod_path")"
              META_JSON="$mod_path/meta.json"

              if [ ! -f "$META_JSON" ]; then
                continue
              fi

              if ! echo "$MOD_DIR" | grep -Eq '^[^@]+@[^@]+$'; then
                echo "- '$MOD_DIR': folder must follow Author@Modname format" >> "$REPORT_FILE"
              fi

              DOWNLOAD_URL=$(jq -r '.downloadURL // empty' "$META_JSON")
              AUTO_CHECK=$(jq -r '."automatic-version-check" // false' "$META_JSON")
              FIXED_RELEASE_UPDATES=$(jq -r '."fixed-release-tag-updates" // false' "$META_JSON")
              IS_TAGGED_RELEASE_ASSET=false
              if echo "$DOWNLOAD_URL" | grep -Eq '^https?://github\.com/[^/]+/[^/]+/releases/download/[^/]+/.+$'; then
                IS_TAGGED_RELEASE_ASSET=true
              fi

              if ! echo "$DOWNLOAD_URL" | grep -Eq '^https?://'; then
                echo "- '$MOD_DIR': downloadURL must start with http:// or https://" >> "$REPORT_FILE"
              fi

              if [ "$AUTO_CHECK" = "true" ]; then
                if echo "$DOWNLOAD_URL" | grep -Eq '/blob/|/tree/|/archive/refs/tags/|/releases/latest$'; then
                  echo "- '$MOD_DIR': automatic-version-check requires an auto-updating file URL" >> "$REPORT_FILE"
                fi

                if [ "$IS_TAGGED_RELEASE_ASSET" = "true" ] && [ "$FIXED_RELEASE_UPDATES" != "true" ]; then
                  echo "- '$MOD_DIR': when automatic-version-check is true and downloadURL is a specific release asset, fixed-release-tag-updates must be true" >> "$REPORT_FILE"
                fi
              fi

              if [ "$FIXED_RELEASE_UPDATES" = "true" ]; then
                if [ "$AUTO_CHECK" != "true" ]; then
                  echo "- '$MOD_DIR': fixed-release-tag-updates requires automatic-version-check=true" >> "$REPORT_FILE"
                fi

                if [ "$IS_TAGGED_RELEASE_ASSET" != "true" ]; then
                  echo "- '$MOD_DIR': fixed-release-tag-updates requires downloadURL to be a specific GitHub release asset URL" >> "$REPORT_FILE"
                fi
              fi
            fi
          done < changed_mods.txt

      - name: Validate Download URLs
        if: steps.find-changed-mods.outputs.changed_mods_found == 'true'
        run: |
          while read -r mod_path; do
            if [ -d "$mod_path" ]; then
              MOD_DIR="$(basename "$mod_path")"
              META_JSON="$mod_path/meta.json"

              if [ ! -f "$META_JSON" ]; then
                continue
              fi

              DOWNLOAD_URL=$(jq -r '.downloadURL // empty' "$META_JSON")
              if [ -z "$DOWNLOAD_URL" ]; then
                echo "- '$MOD_DIR': Missing or empty downloadURL" >> "$REPORT_FILE"
                continue
              fi

              RESULT=$(curl --silent --show-error --location --max-redirs 10 --output /dev/null \
                --write-out "%{http_code}|%{content_type}|%{url_effective}" "$DOWNLOAD_URL")
              HTTP_CODE=$(echo "$RESULT" | cut -d'|' -f1)
              CONTENT_TYPE=$(echo "$RESULT" | cut -d'|' -f2)
              FINAL_URL=$(echo "$RESULT" | cut -d'|' -f3-)

              if [ "$HTTP_CODE" -ge 400 ]; then
                echo "- '$MOD_DIR': downloadURL returned HTTP $HTTP_CODE" >> "$REPORT_FILE"
                continue
              fi

              if echo "$CONTENT_TYPE" | grep -qi '^text/html'; then
                echo "- '$MOD_DIR': downloadURL resolves to HTML page, not file" >> "$REPORT_FILE"
                continue
              fi

              if echo "$FINAL_URL" | grep -Eq '/blob/|/tree/|/releases/latest$|/releases/tag/|github\.com/[^/]+/[^/]+/?$'; then
                echo "- '$MOD_DIR': downloadURL resolves to non-file page URL" >> "$REPORT_FILE"
              fi
            fi
          done < changed_mods.txt

      - name: Determine Validation Status
        id: status
        if: always()
        run: |
          if [ -s "$REPORT_FILE" ]; then
            echo "has_errors=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_errors=false" >> "$GITHUB_OUTPUT"
          fi

          if [ -s "$WARNING_FILE" ]; then
            echo "has_warnings=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_warnings=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment Validation Result
        if: always() && github.event_name == 'pull_request_target'
        uses: actions/github-script@v7
        env:
          HAS_ERRORS: ${{ steps.status.outputs.has_errors }}
          HAS_WARNINGS: ${{ steps.status.outputs.has_warnings }}
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- balatro-validate-comment -->';
            const reportPath = process.env.REPORT_FILE;
            const warningPath = process.env.WARNING_FILE;
            const hasErrors = process.env.HAS_ERRORS === 'true';
            const hasWarnings = process.env.HAS_WARNINGS === 'true';

            function readLines(path, limit = 12) {
              const raw = fs.existsSync(path) ? fs.readFileSync(path, 'utf8').trim() : '';
              const all = raw.split('\n').filter(Boolean);
              const shown = all.slice(0, limit);
              const overflow = all.length - shown.length;
              return { shown, overflow };
            }

            const chunks = [marker];
            if (!hasErrors) {
              chunks.push('Validation passed for changed mod entries.');
            } else {
              const { shown, overflow } = readLines(reportPath);
              chunks.push('Validation found error(s):');
              if (shown.length > 0) {
                chunks.push(...shown);
              } else {
                chunks.push('- Error report file is empty or missing.');
              }
              if (overflow > 0) {
                chunks.push(`- ...and ${overflow} more error(s)`);
              }
            }

            if (hasWarnings) {
              const { shown, overflow } = readLines(warningPath);
              chunks.push('');
              chunks.push('Validation warning(s):');
              if (shown.length > 0) {
                chunks.push(...shown);
              } else {
                chunks.push('- Warning report file is empty or missing.');
              }
              if (overflow > 0) {
                chunks.push(`- ...and ${overflow} more warning(s)`);
              }
            }
            const body = chunks.join('\n');

            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;
            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number,
                per_page: 100
              });

              const existing = comments.find(c => c.user?.type === 'Bot' && c.body?.includes(marker));
              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body
                });
              }
            } catch (error) {
              if (error.status === 403) {
                core.warning('Skipping PR comment because GITHUB_TOKEN lacks write permission in this context (commonly forked PRs).');
                return;
              }
              throw error;
            }

      - name: Publish Validation Report
        if: always() && (steps.status.outputs.has_errors == 'true' || steps.status.outputs.has_warnings == 'true')
        run: |
          report_path="${REPORT_FILE:-$RUNNER_TEMP/validation_report.txt}"
          warning_path="${WARNING_FILE:-$RUNNER_TEMP/validation_warnings.txt}"

          echo "Validation found error(s):"
          if [ -s "$report_path" ]; then
            cat "$report_path"
          else
            echo "- No errors found."
          fi

          if [ -s "$warning_path" ]; then
            echo
            echo "Validation warning(s):"
            cat "$warning_path"
          fi

          {
            echo "## Mod validation summary"
            echo
            echo "### Errors"
            echo '```text'
            if [ -s "$report_path" ]; then
              cat "$report_path"
            else
              echo "No errors found."
            fi
            echo '```'
            echo
            echo "### Warnings"
            echo '```text'
            if [ -s "$warning_path" ]; then
              cat "$warning_path"
            else
              echo "No warnings found."
            fi
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail If Validation Errors Exist
        if: always() && steps.status.outputs.has_errors == 'true'
        run: |
          echo "Validation failed. See the validation report in logs and the job summary."
          exit 1
